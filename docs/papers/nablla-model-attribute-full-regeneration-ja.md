# Nablla 型モデル: 属性駆動・全再構築による非 Virtual DOM Web UI アプローチ

## 第1章 序論

本稿は、HTML・DOM・ブラウザ実行環境という既存の標準技術を前提とし、その上に成立する新しい UI モデルである「属性駆動・全再構築モデル」を体系化することを目的とする。

このモデルは、個別のライブラリやツールの解説ではなく、

> データ（scope） → 属性（attributes） → DOM

という一方向の変換過程を中核とした抽象的な設計原理として定義される。その具体的な運用例として、Nablla（仮称）を参照しながら記述する。

近年の Web 開発では、仮想 DOM 型や宣言的 UI など、DOM 更新を抽象化する多様な方式が提案されてきた。これらはしばしば、内部に仮想的な構造を保持し、差分を計算して実 DOM へ反映する。

これに対し Nablla は、仮想構造を持たず、HTML の属性と DOM をそのまま UI 記述の主役とみなし、UI の変化を

> データの変化 ⇒ 属性の更新 ⇒ DOM の再構築

という直列の流れとして記述する。  
ここで「属性を正とする（attribute-first）」とは、状態の公式な表現形式を属性と DOM に集約し、それ以外に「別の真実の所在」を持たないという意味である。

Nablla は Custom Elements（Web Components）を利用するが、速度向上や局所描画を Web Components の「隠れた最適化」に求めるものではない。本稿での観測結果は、

- ブラウザや DOM 実行環境は、JavaScript による DOM 操作に忠実に従って layout / paint を実行する  
- Web Components であること自体が特別な差分描画を提供するわけではない  

という事実を示している。  
Nablla の特徴は、Web Components の内部に「属性を正とする UI モデル」を閉じ込め、ブラウザ標準の DOM エンジンに直接乗せるという構造にある。

本稿の目的は、Nablla を個別のプロダクトとして宣伝することではなく、そこで得られた設計上・観測上の結果を、

- 属性駆動モデルの概念  
- 内部モデル（scope / attributes / DOM）の定式化  
- 更新手続きと処理フローの整理  
- 仮想 DOM 型ではない UI モデルとしての分類  

として文書化することにある。

本稿の範囲は次のとおりである。

- 属性を基点とするレンダリングモデルの概念整理  
- ブラウザ描画の観測結果に基づく実態の記述  
- Nablla の内部構造と処理手続きの抽象化  
- 仮想 DOM 型モデルとは異なる UI モデルとしての位置づけ  
- 属性中心モデルの学術的・実務的意義の整理  

以降、Nablla という名称は、特定の実装を指す固有名詞であると同時に、「属性駆動・全再構築モデル」を具現化した一例として用いる。

---

## 第2章 本モデルの対象と位置づけ

本章では、本稿が対象とするモデルの射程と、既存の UI モデルとの関係を概念レベルで整理する。

### 2.1 本モデルが扱う対象

本稿の対象は、次の条件を満たす UI 更新モデルである。

1. 状態の一次表現が HTML / DOM の属性に集約されていること  
2. 更新は「テンプレート＋属性」から DOM を再構築する形で行われること  
3. 仮想 DOM や独立のツリー構造を持たないこと  
4. Web 標準 API（Custom Elements, DOM API, イベントモデルなど）の範囲で完結していること  

この性質を持つモデルを、本稿では **「属性駆動・全再構築モデル」** と呼ぶ。

Nablla はこのモデルの具体例として、

- HTML 内に属性としてロジックを記述する  
- Custom Element ごとにテンプレートを保持する  
- `update()` ごとにテンプレートから DOM を再構築する  
- データは scope オブジェクトとして評価され、属性経由で DOM に反映される  

という形で実装されている。

### 2.2 仮想 DOM 型モデルとの違い（概念レベル）

仮想 DOM 型モデルは、おおむね次のような構造を持つ。

- 内部に仮想的な構造（ツリー）を保持する  
- 状態の更新は仮想構造の更新として表現される  
- 仮想構造同士を比較し、差分を計算して実 DOM に反映する  

この方式は

> 状態 → 仮想構造 → 差分 → DOM

という層構造を採用するのに対し、Nablla 型モデルは、

> 状態（scope） → 属性 → DOM

という、より直接的な三段階を前提とする。  
ここで重要なのは、Nablla 自身が「仮想 DOM を持たない」という点であり、「仮想 DOM の性能を超える」といった比較ではない。

仮想 DOM 型モデルが自然に抱える性質として、

- 内部状態と DOM の両方を意識する必要がある  
- 差分計算のロジックが、UI 論理とは別の層に存在する  

といったポイントが挙げられる。  
Nablla 型モデルは、この層構造そのものを採用せず、「属性を正とする」思想のもと、DOM を直接状態の唯一の写像先として扱う。

### 2.3 Web Components の位置づけ

本モデルにおける Web Components（Custom Elements）の役割は、次の二点に集約される。

1. **スコープの境界**  
   各 Nablla 要素はひとつの Custom Element であり、データ scope・テンプレート・ライフサイクルを局所的に持つ。

2. **属性変化のフック**  
   `attributeChangedCallback` 等により、属性変化に反応する標準フックを利用できる。

重要なのは、Web Components 自体が特別な描画最適化を提供するのではなく、「属性変化を契機として内部処理を走らせるための標準フレーム」として利用している点である。

### 2.4 本モデルの位置づけ

以上を踏まえると、Nablla 型のモデルは概念的に次のように位置づけられる。

- 仮想 DOM 型モデルではない  
- 命令的な DOM 操作の集合でもない  
- HTML 属性を主要な記述手段とする UI 言語モデル  
- Custom Elements を単位とするスコープ制御モデル  

本稿は、このモデルを「ひとつの独立した UI 設計体系」として定義し、その内部構造と意味論を整理するものである。

---

## 第3章 属性駆動モデルの基本理念

本章では、「属性を正とする」Nablla モデルの基本理念を整理し、なぜ attribute-first が必然的な選択となり得るのかを説明する。

### 3.1 HTML 属性を「状態」として扱う

HTML は従来、構造と表示を記述するマークアップ言語として利用されてきた。しかし、実際のブラウザ実装では、属性はつねに DOM の状態と直結している。

- 属性の追加・変更・削除は、即座に DOM ノードの状態変化となる  
- 多くの属性は反射属性として扱われ、DOM API と双方向に同期する  
- 属性の有無や値は、スタイル・表示分岐・動作に直接影響する  

この事実から、属性を単なる補助情報ではなく、

> UI 状態を公式に表現するための一次的な媒体

として扱うことが自然である、という立場をとる。  
Nablla の attribute-first は、この立場を明示的な原則として採用している。

### 3.2 「属性 → DOM」という単方向の流れ

DOM は、木構造を持つ動的なオブジェクト表現である。属性の変更は、つねに特定のノードおよび子孫ノードに対する局所的な影響として扱われる。

Nablla 型モデルでは、

> scope の値  
> ⇒ 属性の値  
> ⇒ DOM ノードの状態

という単方向の流れを明示的に設計し、「属性を通らない更新」を基本的に許さない。  
この制約は、一見すると自由度を下げるように見えるが、

- 状態の流れが視覚的・構造的に追跡しやすい  
- DOM と内部状態の乖離が起こりにくい  
- 外部ツールや他スクリプトが属性を操作しても、意味が崩れにくい  

といった利点をもたらす。

### 3.3 テンプレートと属性の関係

Nablla では、各 Custom Element がテンプレート（template）を内部に保持する。しかし、このテンプレートは「別の世界の状態」ではなく、

> 属性を正とする HTML 構造の、静的な原本

として扱われる。  
実行時には、このテンプレートと現在の scope を用いて、属性を含む DOM 構造を再構築する。

ここで重要なのは、

- 意味論の主役はあくまで「属性」である  
- テンプレートは「属性を埋め込んだ HTML の形」を保持する器である  

という関係である。  
このため、本稿では「属性を正とする」思想を前提に、その具現として「テンプレートを正とする再構築」を採用している、と整理する。

### 3.4 attribute-first の必然性

属性を状態の一次表現とすることは、次の意味で「必然性」を持つ。

1. **ブラウザ実装との整合性**  
   属性と DOM はもともと強く結びついており、ここに状態を集約することはブラウザ内部の設計と自然に一致する。

2. **設計上の二重管理の回避**  
   仮想 DOM や別の状態ツリーを持たず、DOM と属性に状態を集約することで、「内部状態」と「表示状態」の二重管理を回避できる。

3. **記述面での一貫性**  
   状態・条件分岐・反復・入力同期などをすべて属性として記述することで、UI の意味論がひとつの記述体系に統合される。

このように、attribute-first は単なる好みではなく、「Web 標準に沿って状態をどこに置くか」という設計選択の結果である。

### 3.5 DOM を唯一の「真」とする

Nablla 型モデルでは、DOM とそこに付与された属性が「唯一の真実の所在」である。  
scope は DOM 生成のための入力であり、テンプレートは DOM の形を定める原本だが、実際にユーザーに提示される構造と状態は DOM によって決まる。

この構造により、

- 仕様書としての HTML  
- 実装としてのテンプレート  
- 実行時状態としての DOM  

が、すべて一貫した形で結びつく。  
ここに、本モデルの基本理念がある。

---

## 第4章 本モデルが依拠する Web 標準技術

本章では、Nablla 型モデルを可能にする Web 標準技術を整理する。

### 4.1 HTML と DOM の対応関係

HTML 文書は、ブラウザや DOM パーサによって DOM ツリーとして再構築される。  
要素・属性・テキストノードは DOM オブジェクトとして表現され、属性変更は Element インターフェースを通じて DOM の状態変化となる。

本モデルは、この「HTML → DOM」の標準的な写像を前提とし、その上に

> scope → 属性 → DOM

という追加の写像を重ねる。  
HTML が UI を記述する言語であるという前提を崩さず、むしろそれを拡張する方向に設計されている。

### 4.2 反射属性と属性操作

多くの属性は反射属性として定義されており、DOM プロパティと相互に反射する。  
これにより、

- 属性操作が DOM 操作と実質的に等価  
- DOM 状態を属性として読み取れる  
- 外部スクリプトと内部実装が、同じ語彙で状態を共有できる  

といった性質が得られる。  
Nablla はこの性質を前提に、「属性＝状態」としての意味付けを行う。

### 4.3 Custom Elements と属性変化フック

Custom Elements 仕様は、属性変化を検知するための `attributeChangedCallback` を定義している。  
Nablla はこれを利用して、

- 特定の属性が変化した瞬間に通知を受ける  
- その変化に応じて `update()` を発火させる  

といった処理を行う。  
ここで重要なのは、属性が変化する入口はどこでもよく、

- ユーザーの操作  
- 外部スクリプトによる書き換え  
- サーバーからのデータ取得  

いずれの場合でも、属性変化として一本化される点である。

### 4.4 Shadow DOM（任意）

Shadow DOM は、必要に応じて DOM 構造やスタイルを局所化するために利用できる。  
本モデルにとって Shadow DOM は必須ではないが、

- スコープの視覚的な境界を明示する  
- スタイルの衝突を避ける  

といった用途に用いられ得る。  
ただし、attribute-first の根幹は Shadow DOM の採否に依存しない。

### 4.5 DOM の再計算と描画

ブラウザや仮想ブラウザは、DOM の変更に従い layout / paint / composite を実行する。  
この内部処理は仕様として細部まで公開されているわけではないが、観測から次の事実が確認できる。

- DOM 操作は、要素単位で記録される  
- レイアウトや描画の範囲は、スタイルや構造に応じて環境内部で決定される  
- Web Components であるかどうかは、多くの場合 reflow / repaint の単位に影響しない  

Nablla 型モデルは、この内部処理を直接制御しない。  
`update()` は DOM を再構築するが、その後の layout / paint は標準的な挙動に委ねる。

### 4.6 イベントモデル

ブラウザのイベントモデルは、DOM ツリーに基づく三相伝播（capture / target / bubble）を持つ。  
Nablla は、属性として定義されたハンドラ（`n-input` 等）を通じて scope の変更を行い、必要に応じて `update()` を呼び出す。

この構造により、

- イベントは DOM 構造に従って伝播し  
- 状態は scope → 属性 → DOM という流れで変化する  

という二つの流れが互いに整合する。

### 4.7 Web 標準の範囲内で完結するモデル

以上の要素はすべて、既存の Web 標準仕様とブラウザ実装に含まれている。  
Nablla 型モデルは、追加のネイティブ API を要求せず、この標準技術の上に

- attribute-first  
- full regeneration  
- scope / template / DOM の一貫モデル  

を構築している。

---

## 第5章 ブラウザ描画の実態と観測結果

本章では、「Web Components なら局所描画になる」「特別な最適化が働く」といった一般的な理解が、本稿の観測結果と一致しなかったことを示し、Nablla 型モデルがどのような前提に立つべきかを整理する。

### 5.1 観測の前提

観測では、次のような手段と条件を用いた。

- `MutationObserver` による DOM 変化の追跡  
- ノード ID の追跡による再利用・再生成の判別  
- ブラウザ開発ツールの paint flashing 等による描画範囲の可視化  
- 1 万?10 万ノード規模の構造に対する `textContent`・属性の一括書き換え  

これらにより、

- どのノードがいつ生成・破棄されるか  
- どの範囲が再描画されるか  

を観察した。

### 5.2 確認された事実

観測結果は次の通りである。

1. **DOM 操作は JavaScript の命令に忠実**  
   `innerHTML` / `textContent` / `setAttribute` 等を実行すると、その内容に応じて DOM ノードが生成・破棄される。  
   Web Components であることを理由とする特別な差分更新は確認されなかった。

2. **layout / paint の範囲は環境内部で決定される**  
   要素全体を更新した場合でも、視覚的には一部のみが変化して見えるケースがあるが、これはブラウザや DOM 実行環境がもともと備える最適化の結果であり、Web Components 特有の機構ではない。

3. **大規模 DOM でも処理は現実的な時間で完了し得る**  
   10 万ノード規模の `textContent` の一括書き換えでも、環境によっては数秒程度で完了する。  
   これは DOM エンジンそのものの性能によるものであり、Nablla が特別な描画制御を行った結果ではない。

### 5.3 誤解の整理

以上から、次のような理解が妥当である。

- 「Web Components だから局所描画になる」というのは誤りである  
- Nablla の UI 更新は、ブラウザ標準の DOM 処理の範囲で完結している  
- 局所的に見える描画は、標準的な最適化の結果であり、Nablla 独自の描画アルゴリズムではない  

### 5.4 Nablla が採用する前提

この観測を前提に、Nablla 型モデルは次のように立脚点を定める。

- 描画そのものを最適化するのではなく、  
  「どのように DOM を記述し、どのように更新するか」を明確化する  

- 性能は、  
  「DOM エンジンをどれだけ素直に使えているか」  
  「余計な抽象化層をどれだけ排除できているか」  
  に依存する  

Nablla の更新モデルは、仮想 DOM や複雑な差分計算を持たず、full regeneration という単純な構造を採用することによって、この前提と整合している。

---

## 第6章 Nablla の独自性と属性駆動制御モデル

本章では、Nablla 型モデルの独自性を、「描画最適化」ではなく「記述モデルと制御構造」に求めて整理する。

### 6.1 属性を正とする UI 記述体系

Nablla は、UI の論理を HTML 属性として記述するための体系を提供する。

- 条件分岐: `*if`, `*elseif`, `*else`  
- 反復: `*for`  
- スコープ拡張: `*let`  
- 入力同期: `*input`  
- 表示反映: `*print`, `:class`, `:style` など  

これらはすべて属性として DOM 上に存在し、「どのノードがどの条件で表示され、どのデータに依存するのか」を HTML レベルで可視化する。

### 6.2 テンプレートと scope による構造化

各 Nablla 要素は、

- 内部テンプレート（template）  
- データ scope  
- 更新手続き（`update()`）  

を一体として保持する。  
テンプレートは「属性を埋め込んだ HTML の原本」であり、scope はそのテンプレート内で評価される値の集合である。

更新時には、

> scope の評価  
> ⇒ 属性の計算  
> ⇒ テンプレートに基づく DOM 再構築  

が行われる。

### 6.3 差分を持たない更新モデル

Nablla の `update()` は、既存 DOM との比較を行わない。代わりに、

- ホストの内部 DOM をリセット  
- テンプレートを評価して新しい DOM を構築  
- 必要に応じて子コンポーネントの `update()` を連鎖的に呼び出す  

という単純な手続きを採用する。  
この「差分を持たない」構造により、

- 更新規則がテンプレートと属性に完全に集約される  
- 状態遷移を追跡するために、別の差分アルゴリズムを理解する必要がない  

という性質が得られる。

### 6.4 仮想 DOM 型モデルの系統に対する応答（概念的）

仮想 DOM 型の方式は、内部に仮想構造を保持することで柔軟な表現を得る一方で、

- 実 DOM と内部状態の二重管理  
- 差分アルゴリズムと UI 論理が別の層に存在する  

という構造的な性質を持つ。  
Nablla 型モデルは、この構造そのものに踏み込まず、

- 仮想 DOM を持たない  
- DOM と属性を唯一の状態表現とする  
- UI 論理と更新規則を属性体系に集約する  

という形で、別系統の回答を提示している。  
これは「仮想 DOM の性能を上回る」という意味ではなく、「仮想 DOM そのものを前提としないモデル」としての独自性である。

### 6.5 Web Components を前提としたスコープ分離

Custom Elements により、各 Nablla 要素は独立したスコープとライフサイクルを持つ。  
これにより、

- 深い階層を持つ UI でも、データの衝突やスコープの混乱を避けられる  
- 親コンポーネントと子コンポーネントが、互いに明示的な境界を保てる  

という構造的な利点が得られる。

### 6.6 独自性の要約

Nablla の独自性は、

- 属性を正とする UI 記述体系  
- full regeneration による簡明な更新モデル  
- Web Components を単位とするスコープ構造  

という三点の組み合わせにある。  
描画そのものを制御するのではなく、「どのように DOM と属性を扱うか」を体系化したモデルである。

---

## 第7章 内部構造と処理過程

本章では、Nablla の `update` 処理と内部モデルを、実装に依存しない抽象手続きとして整理する。

### 7.1 `update` 処理の全体像

`update()` はおおむね次の段階から構成される。

1. 事前ロックと状態準備  
2. scope の評価とテンプレート解釈  
3. DOM の再構築  
4. 後処理とフック呼び出し  

これらは付録 B で段階モデルとして詳細化される。

### 7.2 事前ロックと状態準備

`update()` 開始時には、内部フラグ `_updating` を立てて再入を防止する。続いて、

- `stage` / `buffer` 属性に基づく一時状態の同期  
- `lazy` 等の属性に応じた、子だけ更新か全体更新かの分岐  
- 更新対象となるテンプレートと scope の確定  

が行われる。  
この段階では DOM はまだ書き換えられない。

### 7.3 テンプレート評価

テンプレート評価では、次のような順にディレクティブが解釈される。

- `*if` / `*elseif` / `*else` による条件分岐  
- `*for` による反復展開  
- `*let` による局所スコープの付与  
- `*print` / `:class` / `:style` 等の属性の式評価  

評価結果は、「どのノードが生成され、どの属性が付与されるか」という構造として内部に保持される。

### 7.4 DOM 再構築

DOM 再構築は次の手順で行われる。

- ホスト要素内部の DOM を初期化する  
- テンプレート評価の結果に従って新たなノードを生成する  
- 子コンポーネント（入れ子の Nablla 要素）があれば、それぞれに `update()` を呼び出す  
- 属性・テキストノードを反映する  

ここでは差分比較は行わず、常に「テンプレート＋scope」を基準に DOM を組み立てる。

### 7.5 後処理

DOM 再構築後には、

- ディレクティブを含むノードのインデックス再構築  
- `updated` フックの呼び出し  
- 入力値やフォーカスの復元（可能な範囲で）  
- `_updating` フラグの解除と pending update の整理  

が行われる。  
この後処理により、次回の `update` が安全に実行できる状態が整う。

### 7.6 一貫性の性質

この処理過程により、Nablla 型モデルは次の性質を持つ。

- 決定性: 同じテンプレートと scope からは同じ DOM が生成される  
- 単方向性: scope → 属性 → DOM の流れが明確  
- 冪等性: 同じ scope 状態で連続して `update()` を呼び出しても DOM は変化しない  

付録 C では、これらを内部モデルとして形式化する。

---

## 第8章 利点と体系的位置づけ

本章では、前章までの構造に基づき、Nablla 型モデルがもたらす利点を整理する。

### 8.1 テンプレート規範性による構造安定性

テンプレートを原本として DOM を再構築する設計は、UI の状態遷移に伴う構造破綻を抑制する。

- 複雑な状態遷移が発生しても、`update()` によって DOM はテンプレート準拠の形に戻る  
- 局所的な DOM 操作を積み重ねる方式と異なり、「どの時点でも DOM がテンプレートと同型である」という前提を保てる  

この性質は、UI が複雑化するほど重要になる。

### 8.2 属性体系を中心とした明瞭な更新規則

条件分岐・反復・入力同期・表示反映がすべて属性として記述されることで、

- どのノードがどのデータに依存しているか  
- どの条件で表示／非表示が切り替わるか  

を HTML 上で読み取ることができる。  
これにより、UI の振る舞いを解析する際、別の抽象層に降りていく必要がない。

### 8.3 差分を持たない再構築モデルの予測可能性

差分計算を行わず、フル再構築を前提とすることで、

- 更新規則が単純で、実装も読みやすい  
- 特定の差分ケースに依存した挙動のばらつきが生じにくい  

といった利点が得られる。  
これは、性能のための最適化をあえて削り、「挙動の予測可能性」を優先した選択である。

### 8.4 DOM エンジン最適化との親和性

Nablla 型モデルは、DOM エンジンを直接利用する。仮想 DOM や独自の差分層を挟まないため、

- DOM 操作のパスが短い  
- DOM エンジン内部の最適化をそのまま享受できる  

という意味で、DOM エンジンの最適化と親和性が高い。  
性能評価は第三者が独自に行う必要があるが、本稿の主眼は「性能の絶対値」ではなく「モデルとしての構造」に置かれている。

### 8.5 HTML 主体の記述による長期運用性

Nablla のコードは、HTML ドキュメントの中に完結して存在する。  
これにより、

- UI の挙動が HTML ファイルだけで説明できる  
- 静的サイトジェネレータや CMS など外部ツールとの連携が取りやすい  
- 教育用途において HTML / DOM / 属性の概念を一体として教えやすい  

といった長期運用上の利点も生じる。

### 8.6 体系的位置づけのまとめ

以上の特徴から、Nablla 型モデルは、

- テンプレート規範性  
- attribute-first  
- full regeneration  

を柱とする独立した UI 設計体系として位置づけられる。  
これは、「仮想 DOM 型」「命令的 DOM 操作型」といった他の分類とは別の軸に立つモデルである。

---

## 第9章 学術的位置づけと応用可能性

本章では、Nablla 型モデルを概念モデルとして捉えたときの位置づけと、今後の応用可能性を整理する。

### 9.1 概念モデルとしての三本柱

Nablla 型モデルは概念的に、次の三つの柱から整理できる。

1. **属性中心の意味論**  
   UI の意味論的単位を「属性」とし、条件・反復・入力同期などを属性として記述する。

2. **テンプレート規範性**  
   テンプレートを原本とし、更新時にもテンプレート準拠の構造に戻す。

3. **full regeneration**  
   差分を持たず、テンプレートから DOM を再構築する更新方式。

これら三点の組み合わせが、本モデルを他と区別する。

### 9.2 仮想 DOM 型モデルとの系統的な違い

仮想 DOM 型モデルは、

- 状態を仮想構造として保持し  
- 差分を計算して実 DOM を更新する  

という系統に属する。  
Nablla 型モデルは、

- 仮想構造を持たず  
- 属性と DOM を状態の一次表現とし  
- 再構築モデルを採用する  

という別系統のモデルである。  
この系統差を整理することは、UI モデル研究における分類軸として意味を持つ。

### 9.3 対象とする問題領域

Nablla 型モデルは、次のような問題領域に適合する。

- 階層構造を持つ UI  
- HTML ベースで仕様と実装を統一したいケース  
- 長期間の保守と教育利用を想定した UI  

特に、テンプレートと属性が「事実上の仕様書」として機能するため、UI の意図を文書化しやすい。

### 9.4 教育・文書化への応用

属性体系に基づく UI 設計は、

- HTML / DOM / イベント / 状態管理  

を一体として説明できるため、教育用途との相性が良い。  
また、属性体系をそのまま仕様書に転写できることから、

- UI 仕様記述言語  

としての形式化も将来の研究対象となり得る。

### 9.5 学術的意義

本稿で整理した Nablla 型モデルは、

- テンプレート規範性を前提とする UI モデル  
- 属性中心の意味論を持つ UI 言語  
- full regeneration に基づく更新規則  

という点で、既存の分類では明確に位置づけられてこなかった型に属する。  
この意味で、本モデルは UI 設計理論における独自の枠組みを提供する。

---

## 第10章 まとめ ― Nablla 型モデルの体系

本稿では、Nablla（仮称）を参照しながら、

- 属性を正とする UI モデル  
- テンプレート規範性  
- full regeneration を前提とする更新手続き  

をひとつの体系として整理した。

Nablla 型モデルは、

- 状態を属性と DOM に集約し  
- テンプレートに基づき DOM を再構築し  
- 仮想 DOM を持たない  

という構造を持つ。  
描画の最適化は DOM エンジンに委ねられ、Nablla 自身は「どのように DOM と属性を扱うか」という設計原理に注力する。

本稿の位置づけは、特定の実装の利用方法を説明するマニュアルではなく、

- 属性駆動・全再構築というモデルの概念  
- 内部モデル（scope / attributes / DOM）の定義  
- 処理フローと意味論の整理  

を通じて、ひとつの UI 設計体系を論文化した文書である。  
このモデルは、教育・文書化・テンプレート生成など、今後さまざまな領域に応用可能である。

---

## 付録 A 用語集（Nablla 型モデルの基礎語彙）

### A.1 テンプレート関連

- **テンプレート（template）**  
  UI を構成する HTML 構造の原本。属性を含む形で保存され、更新時に再評価される。

- **テンプレート規範性（template primacy）**  
  UI の構造はテンプレートを正とし、更新後もテンプレートと同型の構造が維持されるという設計原理。

- **テンプレート再構築（template reconstruction）**  
  更新時にテンプレートの構造を基準として DOM を再構築する手続き。

### A.2 属性体系

- **属性体系（attribute-centric model）**  
  UI の動作（条件分岐・繰返し・入力同期など）を HTML 属性として記述する方法。

- **挙動属性（behavioral attributes）**  
  UI の動作規則を定義する属性群（例: `*if`, `*for`, `*let`, `*input`）。

- **構造属性（structural attributes）**  
  テンプレートの構造や生成手続きを指定する属性群（例: `*template`, `*include`）。

- **表示属性（render attributes）**  
  表示時に適用されるクラス・スタイル・その他の反映属性（例: `:class`, `:style`, `:href`）。

- **スコープ（scope）**  
  テンプレート内部で参照可能なデータの束。属性や式はこのスコープに基づいて評価される。

### A.3 更新と再描画

- **再構築モデル（update by template reconstruction）**  
  DOM の更新をテンプレートからの再構築に基づいて行う方式。

- **内部状態（internal state）**  
  UI のデータ（オブジェクト・配列など）。scope として評価され、属性を通じて DOM に反映される。

- **更新規則（update rules）**  
  テンプレート・スコープ・属性体系によって定義される UI 再構築手続きの体系。

- **更新単位（update unit）**  
  `update()` が適用される DOM 範囲。通常は 1 つの Custom Element 内部。

### A.4 入力同期・データフロー

- **入力同期（input binding）**  
  ユーザー入力と内部状態を同期させる仕組み（`*input` など）。

- **データフロー（data flow）**  
  scope → 属性 → DOM の一方向の流れと、入力 → scope という逆方向の流れの総称。

- **スコープ拡張（scope extension）**  
  `*let` などにより、テンプレート内で一時的に変数を導入すること。

### A.5 論理構文・構造制御

- **条件分岐属性（conditional attributes）**  
  `*if` / `*elseif` / `*else` によって DOM ブロックの表示条件を表す属性。

- **反復構造（iteration）**  
  `*for` によって配列や反復可能オブジェクトを表示構造へ展開する仕組み。

- **テンプレート挿入（template expansion）**  
  `*include` などによってテンプレートを埋め込む手法。

### A.6 表示面の反映

- **反映属性（reflection attributes）**  
  表示内容を式によって計算し、DOM に反映させる属性（`*print`, `:class`, `:style` など）。

- **静的反映（static reflection）**  
  初回描画時にのみ評価される反映。

- **動的反映（dynamic reflection）**  
  `update()` のたびに再評価される反映。

### A.7 メタ構造

- **ディレクティブ（directive）**  
  UI 制御を記述するための属性の総称。

- **構造規則（structural rules）**  
  テンプレートから DOM を構築・再構築する際に適用される内部規則。

- **実行モデル（execution model）**  
  テンプレート抽出 → スコープ評価 → DOM 再構築 → 表示反映という一連の処理手順。

### A.8 Nablla 型モデル特有の語彙

- **属性を正とする（attribute-first）**  
  状態の一次表現を属性と DOM に集約し、別の状態ツリーを持たない思想。

- **再構築的更新（reconstructive update）**  
  差分を計算せず、テンプレートに基づいて DOM を再構築する更新手続き。

- **テンプレート優勢（template-first behavior）**  
  実行時の状態がどれだけ変化しても、`update()` によりテンプレート準拠の構造へ戻るという振る舞い。

---

## 付録 B 処理フロー（更新手続きの段階モデル）

本付録では、Nablla 型モデルの `update` 手続きの流れを段階的に定義する。

### B.1 全体構造

更新処理は次の 4 段階から構成される。

1. 事前処理（Pre-processing）  
2. テンプレート評価（Template Evaluation）  
3. DOM 再構築（DOM Reconstruction）  
4. 後処理（Post-processing）

### B.2 事前処理

- 再入防止フラグの設定  
- `stage` / `buffer` 等の一時状態の準備  
- 更新対象となるテンプレートと scope の確定  
- `lazy` 等に基づく「子だけ更新」「全体更新」の分岐決定  

### B.3 テンプレート評価

- 条件分岐属性の評価（`*if` / `*elseif` / `*else`）  
- 反復構造の展開（`*for`）  
- スコープ拡張（`*let`）  
- 反映属性（`*print`, `:class`, `:style` 等）の式評価  

評価結果は、「どのノードを生成し、どの属性を付与するか」という抽象構造として扱われる。

### B.4 DOM 再構築

- ホストの内部 DOM を初期化  
- テンプレート評価結果に基づきノードを生成  
- 子コンポーネント（入れ子の Nablla 要素）の `update` 呼び出し  
- 属性・テキストノードの反映  

### B.5 後処理

- ディレクティブノードのインデックス再構築  
- `updated` フックなどの後処理呼び出し  
- 入力値・フォーカスの復元（可能な範囲）  
- 再入防止フラグの解除と pending update の処理  

### B.6 意義

このフローにより、

- テンプレート規範性  
- 属性体系に基づく挙動の安定  
- 差分を持たない再構築による予測可能性  

が保証される。

---

## 付録 C 内部モデル（Internal Model）

本付録では、Nablla 型モデルの内部構造を形式的に定義する。

### C.1 目的

内部モデルは、

1. scope evaluation（データ評価）  
2. attribute computation（属性生成）  
3. DOM construction and update（DOM 構築と更新）  

の三段階として定義される。

### C.2 スコープモデル（Scope Model）

#### C.2.1 スコープの階層

- **root scope**  
  `data`, `fetch` 等の操作によって得られた基礎データ。

- **local scope**  
  `for`, `let` 等により一時的に導入される局所束縛。

- **stage scope**  
  `stage` / `buffer` 等で一時的に保持される値。

#### C.2.2 評価規則

- 名前解決は inner → outer の順序で行う  
- 解決できない識別子は未定義として扱う  
- 副作用を持つ評価は、モデルが許容する範囲に限定される  

### C.3 属性モデル（Attribute Model）

#### C.3.1 属性の分類

- **バインディング属性**  
  `:value`, `:class`, `:style` 等。scope の値を文字列・フラグメントへ写像する。

- **動作属性**  
  `n-input` 等。DOM イベントと scope の間を媒介する。

- **制御属性**  
  `*if`, `*for`, `*let`, `*template` 等。DOM 構造の生成・非生成を制御する。

#### C.3.2 評価タイミング

- `update()` 実行時に、動的属性はすべて scope に基づき再評価される  
- 制御属性は構造決定に影響し、バインディング属性はノードの属性値を決定する  

### C.4 テンプレート展開モデル（Template Expansion Model）

- テンプレートは初期化時に文字列として取得される  
- 必要に応じて前処理（コメント除去等）が行われる  
- 内部表現（AST 相当）に変換される  

展開規則:

1. 条件分岐の解決（if 系）  
2. 反復の展開（for）  
3. スコープ拡張（let）  
4. 属性評価  
5. 子ノードへの再帰展開  

結果として得られた構造が、DOM 再構築の入力となる。

### C.5 更新モデル（Update Model）

#### C.5.1 `update()` の役割

- scope の最新化  
- テンプレートの再展開  
- DOM の再構築  
- フック呼び出しと内部状態リセット  

#### C.5.2 進行手順

1. 再入防止フラグ設定  
2. stage / buffer 同期  
3. `lazy` 等による更新対象の決定  
4. 内部 DOM のクリア  
5. テンプレート展開と DOM 再構築  
6. インデックス再生成  
7. `updated` フック呼び出し  
8. フラグ解除と pending 処理  

### C.6 一貫性保証

本モデルは次を保証する。

- 決定性: 同じテンプレートと scope なら同じ DOM  
- 単方向性: scope → 属性 → DOM  
- 冪等性: 同じ scope での連続 `update` による DOM 不変  
- 局所スコープの遮断: local scope は外側に影響しない  

### C.7 モデルの制限

- 差分計算による更新最適化は提供しない  
- レイアウトやペイントなど描画戦略の詳細には踏み込まない  
- 巨大 DOM 構造に対する更新コストは環境に依存する  

本内部モデルは、Nablla 型モデルが採用する設計上の前提と保証を明示し、属性駆動・全再構築という UI モデルを形式的に説明するための基盤である。
